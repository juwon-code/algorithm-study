# algorithm-study

목차

---

### 알고리즘 설계 기법

#### 욕심쟁이 방법(Greedy Algorithm)

해를 구하는 일련의 선택 과정에서 선택과는 상관없이, 가장 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적인 전략을 취하는 방법.

- 최솟값 및 최댓값을 구하는 최적화 문제에서 주로 사용한다.
- 국부적인 최적해가 전체 최적해를 구성하지 못하는 경우도 존재한다.

대표적인 응용문제로는 거스름돈 문제, 배낭 문제 등이 있고, 그래프 알고리즘으로 [크루스칼 알고리즘](#크루스칼-알고리즘), [프림 알고리즘](#프림-알고리즘), [데이크스트라 알고리즘](#데이크스트라-알고리즘)이 있다.

#### 분할정복 방법(Divide and Conquer)

순환적으로 문제에 접근하는 **하향식 접근 방법(top-down)** 으로 문제를 2개 이상의 작은 문제로 분할하고, 각각 해결한 뒤 결합하여 원래 문제의 해를 구하는 방식이다. 즉, 분할-정복-결합의 과정을 순환적으로 수행한다.

- 분할된 문제들은 원래 문제에서 크기만 작아진 형태이다.
- 분할된 문제들은 서로 독립적으로 접근한다.

대표적인 응용문제로는 [퀵 정렬](#퀵-정렬quick-sort), [합병 정렬](#합병-정렬merge-sort), 이진 탐색 등이 있다.

#### 동적 프로그래밍(Dynamic Programming)

입력의 크기가 작은 부분부터 테이블에 저장하고, 큰 문제의 해를 점진적으로 만들어가는 **상향식 접근 방법(bottom-up)** 이다.

- 작은 문제들은 원래 문제에서 크기만 작아진 형태이다.
- 작은 문제들은 서로 독립적일 필요가 없다.

대표적인 응용문제로는 행렬의 연쇄곱, 최장 공통 부분 수열 등이 있고, 그래프 알고리즘으로 [플로이드 알고리즘](#플로이드-알고리즘)이 있다.

---

### 비교 기반 정렬 알고리즘

#### 선택 정렬(Selection Sort)

입력 배열을 가장 작은 값부터 순서대로 선택하여 나열하는 방식이다.

- 입력 상태와 관계없이 항상 동일한 성능 $O(n^2)$을 갖는다.
- 상수 개의 저장 공간만 필요한 **제자리 정렬 알고리즘**이다.
- 동일한 값의 위치가 바뀔 수 있는 **안정적이지 않은 알고리즘**이다.

#### 버블 정렬(Bubble Sort)

인접한 데이터를 차례대로 비교하며 자리를 바꾸는 과정을 반복하는 방식이다.

- 입력 상태와 관계없이 항상 동일한 성능 $O(n^2)$을 갖는다.
- 상수 개의 저장 공간만 필요한 **제자리 정렬 알고리즘**이다.
- 인접한 데이터가 동일한 경우 교환하지 않는 **안정적인 알고리즘**이다.

#### 삽입 정렬(Insertion Sort)

미정렬 부분에서 데이터를 하나씩 뽑은 후 정렬 부분에 삽입하여 나열하는 방식이다.

- 정렬된 경우 $O(n)$, 역순으로 정렬된 경우 $O(n^2)$의 성능을 갖는다.
- 상수 개의 저장 공간만 필요한 **제자리 정렬 알고리즘**이다.
- 인접한 데이터가 동일한 경우 교환하지 않는 **안정적인 알고리즘**이다.

#### 셸 정렬(Shell Sort)

멀리 떨어진 데이터와의 교환으로 삽입 정렬의 성능을 보완한 정렬 알고리즘이다.

- 사용하는 순열에 따라서 $O(nlogn)$, $O(n^2)$의 성능을 갖는다.
- 상수 개의 저장 공간만 필요한 **제자리 정렬 알고리즘**이다.
- 간격에 따라서 동일한 값의 위치가 바뀔 수 있는 **안정적이지 않은 알고리즘**이다.

#### 퀵 정렬(Quick Sort)

특정 데이터 피벗으로 2개의 부분배열로 분할하여, 각 배열에 다시 퀵 정렬을 순환적으로 적용하는 방식이다.

- 부분 배열이 항상 중앙에서 분리되는 경우 $O(nlogn)$의 성능을 갖는다.
- 부분 배열이 항상 최소, 최대로 분리되는 경우 $O(n^2)$의 성능을 갖는다.
- 상수 개의 저장 공간만 필요한 **제자리 정렬 알고리즘**이다.
- 피벗에 따라서 동일한 값의 위치가 바뀔 수 있는 **안정적이지 않은 알고리즘**이다.

분할정복 방법이 적용된 알고리즘이나, 결합은 필요하지 않다.

#### 합병 정렬(Merge Sort)

입력 배열을 동일한 크기의 부분배열로 분할하고, 각 배열에 다시 합병 정렬을 순환적으로 적용한 후, 합병하여 하나의 배열로 정렬하는 방식이다.

- 입력 상태와 관계없이 항상 동일한 성능 $O(nlogn)$을 갖는다.
- 입력 크기 $n$만큼의 공간이 필요하며 **제자리 정렬 알고리즘**이 아니다.
- 합병 과정에서 왼쪽 데이터를 우선적으로 선택하는 **안정적인 알고리즘**이다.

#### 힙 정렬(Heap Sort)

입력 배열을 완전 이진 트리 구조의 힙으로 변환하여 정렬하는 방식이다.

- 입력 상태와 관계없이 항상 동일한 성능 $O(nlogn)$을 갖는다.
- 상수 개의 저장 공간만 필요한 **제자리 정렬 알고리즘**이다.
- 정렬 과정에서 동일한 값의 위치가 바뀔 수 있는 **안정적이지 않은 알고리즘**이다.

---

### 데이터 분포 정렬 알고리즘

#### 계수 정렬(Counting Sort)

입력값의 범위를 알고 있을 경우, 데이터의 개수를 계산하여 정렬할 위치를 찾고 정렬하는 방식이다.

- 입력 값의 범위와 관계없이 동일한 선형 시간의 성능 $O(n)$을 갖는다.
- 계수 배열, 결과 배열의 공간이 필요하며 **제자리 정렬 알고리즘**이 아니다.
- 입력 배열의 오른쪽 값부터 결과 배열의 오른쪽에 저장하는 **안정적인 알고리즘**이다.

#### 기수 정렬(Binary Sort)

입력 데이터의 자릿수가 상수일 경우, 입력값을 자릿수를 기준으로 부분 비교하여 정렬하는 방식이다. 진행 순서에 따라서 **LSD(Least Significant Digit)**, **MSD(Most Significant Digit)** 로 나눌 수 있다.

- 입력 상태와 관계없이 항상 동일한 선형 시간의 성능 $O(n)$을 갖는다.
- 전체 데이터 개수와 진법 크기 만큼의 공간이 필요하며 **제자리 정렬 알고리즘**이 아니다.
- 각 자릿수 별로 안정적인 정렬 알고리즘을 적용하므로 **안정적인 알고리즘**이다.

#### 버킷 정렬(Bucket Sort)

입력 데이터가 균등하게 분포될 때, 값의 범위를 균등하게 나눈 버킷을 만들고, 각 버킷에 [삽입정렬](#삽입-정렬insertion-sort)과 같은 안정적인 정렬을 수행하여 정렬하는 방식이다.

- 입력값이 균등하게 분포될 때 선형 시간의 성능 $O(n)$을 갖는다.
- 버킷 배열, 결과 배열의 공간이 필요하며 **제자리 정렬 알고리즘**이 아니다.
- 버킷에 삽입할 때, 정렬 과정에서 순서를 유지하는 **안정적인 알고리즘**이다.

---

### 탐색 알고리즘

#### 순차 탐색(Sequential Search)

정렬되지 않고 크기가 작은 데이터에 적합하며, 리스트나 배열로 주어진 원소들을 처음부터 하나씩 비교하며, 원하는 값을 찾는 탐색 방식이다.

- 탐색 및 삭제 연산에 $O(n)$의 성능을 갖는다.
- 삽입 연산에 $O(1)$의 성능을 갖는다.

#### 이진 탐색(Binary Search)

정렬된 리스트나 배열로 주어진 원소들을 절반씩 줄여가며 원하는 값을 찾는 탐색 방식이다.

- 탐색 및 초기화 연산에 $O(nlogn)$의 성능을 갖는다.
- 삽입 및 삭제 연산에 $O(n)$의 성능을 갖는다.

즉, 삽입과 삭제가 빈번한 경우에는 적합하지 않다.

#### 이진 탐색 트리(Binary Search Tree)

리스트나 배열이 이진 트리로 주어질 때, 한 노드를 기준으로 값이 작을 경우 왼쪽 서브트리로, 클 경우 오른쪽 서브트리로 이동하며 값을 찾는 탐색 방식이다.

- 모든 노드의 차수가 1인 경우, 최악의 $O(n)$의 성능을 갖는다.
- 모든 노드의 차수가 2인 경우, 최선의 $O(logn)$의 성능을 갖는다.

#### 2-3-4 트리(2-3-4 Tree)

리스트나 배열이 2-노드, 3-노드- 4-노드의 형태를 만족하는 균형 탐색 트리의 형태로 주어질 때, 한 노드를 기준으로 값이 작을 경우 왼쪽 서브트리로, 클 경우 오른쪽 서브트리로 이동하며 값을 찾는 탐색 방식이다.

- 트리 높이는 최대 $logn$ 이며, 탐색, 삽입, 삭제 연산이 항상 $O(logn)$의 성능을 갖는다.
- 삽입 및 삭제 과정에서 경사트리가 되지 않는다.
- 2-3-4 트리를 그대로 구현하면 이진 탐색 트리보다 느려질 수 있다.

#### 레드-블랙 트리(Red-Black Tree)

2-3-4 트리의 균형을 유지하기 위해서 다음 규칙을 적용한 트리이다.

- 모든 노드는 검정, 빨강이며, 루트 노드와 리프 노드는 검정이다.
- 빨강 노드의 부모 노드는 항상 검정이며, 경로상에 동일한 검정 노드가 존재한다.

삽입 연산에서는 리프 노드에 빨강으로 추가하며 다음 규칙을 적용한다.

- 부모 노드의 형제 노드가 빨강인 경우 부모, 부모의 형제, 조부모 노드의 색깔을 반전한다.
- 부모 노드의 형제 노드가 검정이고 부모 노드의 값과 사이인 경우, 현재 노드와 부모 노드를 회전한다.
- 부모 노드의 형제 노드가 검정이고 부모 노드와 조부모 노드의 키값이 크거나 작은 경우, 부모 노드와 조부모 노드를 회전하고 색깔을 반전한다.

결론적으로 다음 특징을 갖는다.

- 임의의 리프 노드의 레벨 차이가 2배를 넘지 않는 균형 탐색 트리이다.
- 트리 높이는 최대 $O(logn)$ 이며, 탐색, 삽입, 삭제 연산이 항상 $O(logn)$의 성능을 갖는다.

#### B-트리(B-Tree)

다음 규칙을 만족하는 균형 탐색 트리이다.

- 루트 노드는 $1<=k<2t$의 오름차순으로 정렬된 키를 갖는다.
- 다른 노드는 $t-1<=k<2t$의 오름차순으로 정렬된 키를 갖는다.
- 내부 노드는 키의 개수보다 하나 많은 자식 노드를 갖는다.

결론적으로 다음 특징을 갖는다.

- 탐색, 삽입, 삭제 연산에서 $O(logn)$의 성능을 갖는다.
- 외부 탐색과 외부 탐색에서 모두 활용할 수 있다.

#### 해시 테이블(Hash Table)

키 값을 기반으로 데이터의 저장 위치를 계산하여 상수 시간에 데이터를 저장, 삭제, 탐색할 수 있는 방법이다. 해싱이 적합한 형태의 응용 문제는 다음과 같다.

1. 동일한 키값을 갖는 데이터가 여러 개 있는 문제.
2. 특정 범위의 키값을 가진 모든 데이터를 탐색하는 문제.
3. 최대, 최소 키값을 가진 데이터를 찾는 문제.
4. 키값의 순서대로 데이터를 방문하는 문제.
5. 특정 키값의 데이터를 찾는 문제.

해시함수의 종류로는 제산 잔여법, 비닝, 중간 제곱법, 문자열 함수(비닝, 단순 합, 가중 합) 등이 있다.

> **제산 잔여법**  
> 키값 $k$를 해시 테이블의 크기 $m$으로 나눈 나머지 $r$을 주소로 사용한다. 나머지는 키값의 하위 $r$ 비트의 값이 되기 때문에, 전체 비트를 주소 계산에 활용할 수 없게 된다. 따라서 거듭제곱과 최대한 거리가 있는 소수를 사용한다. 구체적인 수식은 다음과 같다. $$h(k) = k \% m$$

> **비닝**  
> 키값의 범위 $U$를 테이블의 크기 $M$으로 나눈 슬롯에 삽입한다. 상위 비트의 분포가 고르지 않을 경우, 특정 슬롯에 집중되는 문제가 발생할 수 있다.

> **중간 제곱법**  
> 키값을 제곱한 결과 $k^2$에 사용하지 않을 하위 비트 크기 $2^m$을 나누고, 해쉬 주소로 사용할 비트 $2^r$로 나눈 나머지를 주소로 사용한다. 대부분의 비트가 결과 생성에 기여됨으로써 자리 분포에 따른 영향을 받지 않는다. 구체적인 수식은 다음과 같다. $$h(k)=(k^2/2^m)\%2^r$$

> **문자열 비닝**  
> 문자열의 앞쪽 일부를 해시 결과로 사용한다. 앞쪽의 분포가 고르지 못할 경우, 슬롯에 고르게 분포되지 않을 수 있다.

> **문자열 단순합**  
> 각 문자의 코드값을 합하고 제산 잔여법을 적용한다. 짧은 문자열에 대해서는 비효과적이며, 문자의 출현 순서는 고려되지 않아 주소가 중복된다.

> **문자열 가중합**  
> 각 문자의 코드값에 자릿수에 따른 가중치를 곱하고 합한 뒤 제산 잔여법을 적용한다. 즉, 문자열 단순합의 출현 문자가 같을 때 발생하는 주소 중복을 방지할 수 있다.

서로 다른 값의 키가 일치할 때 충돌이 발생하는데, 충돌 해결 방법으로는 충돌된 데이터를 테이블 밖의 별도의 장소에 저장하는 **개방 해싱**, 해시 테이블의 다른 슬롯에 저장하는 **폐쇄 해싱**이 았다. 폐쇄 해싱의 종류로는 버킷 해싱, 선형 탐사, 이차 탐사, 이중 해싱이 있다.

> **버킷 해싱**  
> 해시 테이블의 슬롯을 버킷으로 나누어 버킷 단위로 관리한다. $$h(k)=k\%10$$

> **선형 탐사**  
> 해당 슬롯이 사용중일 경우, 다음 슬롯으로 순차적으로 데이터를 삽입한다. 이는 필연적으로 긴 탐사 순서를 만들어서 탐색 시간의 낭비를 가져오는 **1차 클러스터링 문제**를 야기한다. 구체적인 수식은 다음과 같다. $$p(k,i)=(k+i)%10$$

> **이차 탐사**  
> 충돌이 발생하는 횟수의 제곱 형태로 탐사 순서를 결정하여, 다른 홈 슬롯을 갖는 키는 다른 탐사 순서를 갖게된다. 그러나 동일한 홈 슬롯을 가지는 키들은 동일한 탐사 순서를 갖는 **2차 클러스터링 문제**를 야기한다. 구체적인 수식은 다음과 같다. $$p(k,i)=(h(k)+c_1*i^2+c_2*i^2+c_3*i^2)\%m$$

> **이중 해싱**
> 탐사 순서를 원래의 키값을 사용하여 해싱하면 1, 2차 클러스터링 문제를 해결할 수 있다. 탐사 순서의 모든 상수가 해시 테이블의 크기 $m$과 서로소가 되어야만 한다. 구체적인 수식은 다음과 같다. $$p(k,i)=(h_1(k)+i*h_2(k))\%m$$

---

### 그래프 알고리즘

#### 크루스칼 알고리즘

#### 프림 알고리즘

#### 데이크스트라 알고리즘

#### 플로이드 알고리즘